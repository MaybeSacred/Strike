// //Created by Jon Tyson : jtyson3@gatech.edu
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;

[System.Serializable]
public class BayesianNetwork
{
	float[][]
		net;
	public static readonly float gaussianCutoff = 3;
	public BayesianNetwork (int width, int height)
	{
		net = new float[width][];
		for (int i = 0; i < width; i++) {
			net [i] = new float[height];
			for (int k = 0; k < net[i].Length; k++) {
				net [i] [k] = 1;
			}
		}
		NormalizeNet ();
	}
	/// <summary>
	/// Normalizes the net.
	/// L1 normalization
	/// </summary>
	void NormalizeNet ()
	{
		float sum = 0;
		for (int i = 0; i < net.Length; i++) {
			for (int k = 0; k < net[i].Length; k++) {
				sum += net [i] [k];
			}
		}
		sum = (sum == 0) ? 1 : sum;
		for (int i = 0; i < net.Length; i++) {
			for (int k = 0; k < net[i].Length; k++) {
				net [i] [k] /= sum;
			}
		}
	}
	/// <summary>
	/// Applies the gaussian function, averaging each affected cell with 
	/// its old value weighted by gaussian of distance to affected cell
	/// </summary>
	/// <param name="center">Center.</param>
	/// <param name="value">Value.</param>
	void ApplyGaussian (Vector2 center, float value)
	{
		for (int i = 0; i < net.Length; i++) {
			for (int k = 0; k < net[i].Length; k++) {
				var dist = TerrainSupporter.ManhattanDistance (new Vector3 (i, 0, k), new Vector3 (center.x, 0, center.y));
				if (dist <= gaussianCutoff) {
					Debug.Log ("Before " + net [i] [k]);
					var gauss = Gaussian (new Vector2 (center.x - i, center.y - k));
					net [i] [k] = .5f * gauss * value + (1 - .5f * gauss) * net [i] [k];
					Debug.Log ("After " + net [i] [k]);
				}
			}
		}
	}
	float Gaussian (Vector2 offset)
	{
		return (1 / (2 * Mathf.PI)) * Mathf.Exp (-(offset.x * offset.x + offset.y * offset.y) / 2);
	}
	/// <summary>
	/// Updates the network with a new value centered at (x,y).
	/// </summary>
	/// <param name="x">The x coordinate.</param>
	/// <param name="y">The y coordinate.</param>
	/// <param name="value">Value.</param>
	public void UpdateNetwork (float x, float y, float value)
	{
		ApplyGaussian (new Vector2 (x, y), value);
		NormalizeNet ();
	}

	public float GetValue (float x, float z)
	{
		return net [Mathf.RoundToInt (x)] [Mathf.RoundToInt (z)];
	}

	public void SaveNet(String name){
		BinaryFormatter bf = new BinaryFormatter();
		FileStream file = File.Create (Application.persistentDataPath + "/"+name+".gd");
		bf.Serialize(file, net);
		file.Close();
	}


	public void LoadNet(String name){

		if(File.Exists(Application.persistentDataPath +  "/"+name+".gd")) {
			BinaryFormatter bf = new BinaryFormatter();
			FileStream file = File.Open(Application.persistentDataPath + "/"+name+".gd", FileMode.Open);
			net = (float[][])bf.Deserialize(file);
			file.Close();
		}
	}

}

