// //Created by Jon Tyson : jtyson3@gatech.edu
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

class NavalProduction
{
	public NavalProduction ()
	{
	}

	public List<ProductionEngine.ProductionRule> GetRules ()
	{
		List<ProductionEngine.ProductionRule> rules = new List<ProductionEngine.ProductionRule> ();
		rules.Add (CarrierRule);
		rules.Add (SubmarineRule);
		rules.Add (CorvetteRule);
		rules.Add (DestroyerRule);
		rules.Add (BoomerRule);
		rules.Add (NavalInteractionRule);
		return rules;
	}
	/// <summary>
	/// When to build a carrier
	/// </summary>
	/// <returns>The rule.</returns>
	/// <param name="data">Data.</param>
	/// <param name="thisPlayer">This player.</param>
	List<Tuple<UnitName, float>> CarrierRule (Instance data, Player thisPlayer)
	{
		List<Tuple<UnitName, float>> outList = new List<Tuple<UnitName, float>> ();
		var enemyAirUnits = data.GetEnemyAirUnitCount ();
		if (thisPlayer.funds > (Utilities.GetPrefabFromUnitName (UnitName.Corvette) as UnitController).baseCost) {
			if (enemyAirUnits > data.GetEnemyNavalUnitCount ()) {
				if (data.playerUnitCount [(int)UnitName.Carrier] < 2) {
					outList.Add (new Tuple<UnitName, float> (UnitName.Carrier, .25f));
				}
			}
		}
		return outList;
	}
	/// <summary>
	/// When to build submarines
	/// </summary>
	/// <returns>The rule.</returns>
	/// <param name="data">Data.</param>
	/// <param name="thisPlayer">This player.</param>
	List<Tuple<UnitName, float>> SubmarineRule (Instance data, Player thisPlayer)
	{
		List<Tuple<UnitName, float>> outList = new List<Tuple<UnitName, float>> ();
		// Build a submarine if theres an enemy carrier
		if (data.enemyAverageUnitCount [(int)UnitName.Carrier] > 0) {
			if (data.playerUnitCount [(int)UnitName.Submarine] < 1) {
				outList.Add (new Tuple<UnitName, float> (UnitName.Submarine, 2));
			} else {
				outList.Add (new Tuple<UnitName, float> (UnitName.Submarine, .75f));
			}
		}
		// Build a submarine if theres a lot of enemy ships
		if (data.enemyAverageUnitCount [(int)UnitName.Corvette] + data.enemyAverageUnitCount [(int)UnitName.Destroyer] >= 1) {
			if (data.playerUnitCount [(int)UnitName.Submarine] < 2) {
				outList.Add (new Tuple<UnitName, float> (UnitName.Submarine, 1));
				if (data.enemyAverageUnitCount [(int)UnitName.Corvette] + data.enemyAverageUnitCount [(int)UnitName.Destroyer] +
					data.enemyAverageUnitCount [(int)UnitName.SupplyShip] >= 4) {
					outList.Add (new Tuple<UnitName, float> (UnitName.Submarine, .5f));
				}
			} else {
				outList.Add (new Tuple<UnitName, float> (UnitName.Submarine, .5f));
			}
		}
		return outList;
	}
	/// <summary>
	/// When to build a corvette ship
	/// </summary>
	/// <returns>The rule.</returns>
	/// <param name="data">Data.</param>
	/// <param name="thisPlayer">This player.</param>
	List<Tuple<UnitName, float>> CorvetteRule (Instance data, Player thisPlayer)
	{
		List<Tuple<UnitName, float>> outList = new List<Tuple<UnitName, float>> ();
		if (data.enemyAverageUnitCount [(int)UnitName.Submarine] > .5f) {
			if (data.enemyAverageUnitCount [(int)UnitName.Submarine] > 1.5f && data.playerUnitCount [(int)UnitName.Corvette] <= 2f) {
				outList.Add (new Tuple<UnitName, float> (UnitName.Corvette, 2f));
			} else {
				outList.Add (new Tuple<UnitName, float> (UnitName.Corvette, .75f));
			}
		}
		// Build corvette if theres enemy air units
		if (data.enemyAverageUnitCount [(int)UnitName.CarpetBomber] + data.enemyAverageUnitCount [(int)UnitName.AttackCopter] +
			data.enemyAverageUnitCount [(int)UnitName.TacticalFighter] + data.enemyAverageUnitCount [(int)UnitName.Interceptor] >= 2) {
			if (data.playerUnitCount [(int)UnitName.Corvette] <= 1f) {
				outList.Add (new Tuple<UnitName, float> (UnitName.Corvette, 1f));
			} else {
				outList.Add (new Tuple<UnitName, float> (UnitName.Corvette, .5f));
			}
		}
		// Lower priority build one anyways
		if (data.playerUnitCount [(int)UnitName.Corvette] < 1) {
			outList.Add (new Tuple<UnitName, float> (UnitName.Corvette, .5f));
		}
		return outList;
	}
	/// <summary>
	/// When to build a destroyer
	/// </summary>
	/// <returns>The rule.</returns>
	/// <param name="data">Data.</param>
	/// <param name="thisPlayer">This player.</param>
	List<Tuple<UnitName, float>> DestroyerRule (Instance data, Player thisPlayer)
	{
		List<Tuple<UnitName, float>> outList = new List<Tuple<UnitName, float>> ();
		// Build destroyer if theres enemy ships
		if (data.enemyAverageUnitCount [(int)UnitName.Corvette] + data.enemyAverageUnitCount [(int)UnitName.Destroyer] +
			data.enemyAverageUnitCount [(int)UnitName.Carrier] >= 2) {
			if (data.playerUnitCount [(int)UnitName.Destroyer] < 1f) {
				outList.Add (new Tuple<UnitName, float> (UnitName.Destroyer, 1f));
			} else if (data.playerUnitCount [(int)UnitName.Destroyer] < 3f) {
				outList.Add (new Tuple<UnitName, float> (UnitName.Destroyer, .66f));
			} else {
				outList.Add (new Tuple<UnitName, float> (UnitName.Destroyer, .4f));
			}
		}
		// Lower priority build one anyways
		if (data.playerUnitCount [(int)UnitName.Destroyer] < 1) {
			outList.Add (new Tuple<UnitName, float> (UnitName.Destroyer, .2f));
		}
		return outList;
	}
	/// <summary>
	/// When to build a boomer anti-everything sub
	/// </summary>
	/// <returns>The rule.</returns>
	/// <param name="data">Data.</param>
	/// <param name="thisPlayer">This player.</param>
	List<Tuple<UnitName, float>> BoomerRule (Instance data, Player thisPlayer)
	{
		List<Tuple<UnitName, float>> outList = new List<Tuple<UnitName, float>> ();
		// build a boomer if we have high income or monies
		if (thisPlayer.properties.Count > 14 || thisPlayer.deltaFunds > 14000 || thisPlayer.funds > 20000) {
			if (data.playerUnitCount [(int)UnitName.Boomer] < 1) {
				outList.Add (new Tuple<UnitName, float> (UnitName.Boomer, .75f));
			} else {
				outList.Add (new Tuple<UnitName, float> (UnitName.Boomer, .5f));
			}
		}
		return outList;
	}
	List<Tuple<UnitName, float>> SupplyShipRule (Instance data, Player thisPlayer)
	{
		List<Tuple<UnitName, float>> outList = new List<Tuple<UnitName, float>> ();
		// build a boomer if we have high income or monies
		if (data.playerUnitCount [(int)UnitName.SupplyShip] < 1) {
			outList.Add (new Tuple<UnitName, float> (UnitName.SupplyShip, 1));
		} else if (data.playerUnitCount [(int)UnitName.SupplyShip] < 2) {
			outList.Add (new Tuple<UnitName, float> (UnitName.SupplyShip, .5f));
		} else if (data.playerUnitCount [(int)UnitName.SupplyShip] < 4) {
			outList.Add (new Tuple<UnitName, float> (UnitName.SupplyShip, .25f));
		}
		return outList;
	}
	/// <summary>
	/// Some general conditions and how different naval units should balance
	/// </summary>
	/// <returns>The interaction rule.</returns>
	/// <param name="data">Data.</param>
	/// <param name="thisPlayer">This player.</param>
	List<Tuple<UnitName, float>> NavalInteractionRule (Instance data, Player thisPlayer)
	{
		List<Tuple<UnitName, float>> outList = new List<Tuple<UnitName, float>> ();
		if (1.5f * (data.enemyAverageUnitCount [(int)UnitName.Submarine] + data.enemyAverageUnitCount [(int)UnitName.Boomer]) > 
			data.enemyAverageUnitCount [(int)UnitName.Corvette] + data.enemyAverageUnitCount [(int)UnitName.Destroyer]) {
			outList.Add (new Tuple<UnitName, float> (UnitName.Boomer, -.25f));
			outList.Add (new Tuple<UnitName, float> (UnitName.Submarine, -.25f));
			outList.Add (new Tuple<UnitName, float> (UnitName.Corvette, .4f));
		} else {
			outList.Add (new Tuple<UnitName, float> (UnitName.Submarine, .25f));
			outList.Add (new Tuple<UnitName, float> (UnitName.Corvette, -.25f));
			outList.Add (new Tuple<UnitName, float> (UnitName.Destroyer, .25f));
		}
		return outList;
	}
}
